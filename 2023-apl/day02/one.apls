psuedocode:

* procedural
  * initialize a variable `count` to 0
  * split each line into an array.
    * the first member of the array should be "Game n"
    * every non-first member of the array should be a set of shown cubes, something like  "n red, m blue, k green", where `n`, `m`, and `k` are numbers
  * iterate through every member of the array after the first and find:
    * r = the largest number of shown cubes for red
    * g = the largest number of shown cubes for green
    * b = the largest number of shown cubes for blue
  * determine if r > 12, g > 13, or if b > 14. if yes then skip
  * otherwise add the gameID to `count`
  * print the count at the end

* create array where each element is a line
* create a function `fn` that takes a line as input. The function will:
  * split the line into an array.
    * the first member of the array should be "Game n"
    * every non-first member of the array should be a set of shown cubes, something like  "r red, g green, b blue", where `r`, `g`, and `b` are numbers
  * parse the first member to be a number `n`
  * parse each non-first member so as to convert it to an array of three elements: [r, g, b]
  * our current array looks like this [n, [r, g, b], [r, g, b], [r, g, b]].
  * transform the vectors to be a matrix so that we have this:
  ```
  |------------------|
  | n, |-----------| |
  |    | r   g   b | |
  |    | r   g   b | |
  |    | r   g   b | |
  |    |-----------| |
  |------------------|

  ```
  * get max of every column of the matrix so that we have this (where R, G, B is the max of a col)
  ```
  |------------------|
  | n, |-----------| |
  |    | R   G   B | |
  |    |-----------| |
  |------------------|

  ```
  * subtract the second element of the array by [12 13 14]
  * if any of the elements of the array are smaller than 0, then return 0, otherwise, return `n`
* map each element through `fn` to create a new array
* sum up all the elements of this new array

⍝ partition by ':' and ';'
line⊆⍨~line ∊ ':' ';'

⍝ 1. keep only numbers in the first element
(({⍵/⍨⍵∊⎕d}⊃),1∘↓)line⊆⍨~line ∊ ':' ';'

⍝ 2. split all the draws from non-first elements
{⍵⊆⍨~', '⍷⍵}¨1∘↓line⊆⍨~line ∊ ':' ';'

⍝ combined 1 and 2 
(({⍵/⍨⍵∊⎕d}⊃),({⍵⊆⍨~', '⍷⍵}¨1∘↓))line⊆⍨~line ∊ ':' ';'

(({⍵/⍨⍵∊⎕d}⊃),({{⍵⊆⍨~' '∊⍨⍵}¨⍵⊆⍨~', '⍷⍵}¨1∘↓))line⊆⍨~line ∊ ':' ';'


{⍵⊆⍨~⊃+⌿(2 1 ⍴ ', ' '; ') ⍷ ¨⊂⍵}⊃1∘↓line⊆⍨~line ∊ ':'



⍝ final attempt
calcRotation ← {
   3≡≢⍵~0:0
   2≡≢⍵~0:⊃1-⍨⍸⌽~⍵
   ⊃⍸⌽⍵
}
getNumber ← {
  splitLine ← line⊆⍨~line ∊ ':'

  ⍝ first part of a line is a gameID, parse it into int and save
  gameID ← ⍎⊃{⍵/⍨⎕d∊⍨⍵}⊃splitLine

  ⍝ convert second part of line to an array of arrays. each inner array is two elements: a number and a color
  sndPart ← {⍵⊆⍨~⍵ ∊ ' '}¨{⍵⊆⍨~⊃+⌿(2 1 ⍴ ', ' '; ') ⍷ ¨⊂⍵}⊃1↓splitLine 

  ⍝ create a 3x2 matrix. 1st column is color names. 2nd column are the drawings of that color
  m ← (2⊃¨sndPart) {⍺ (⊃¨⍵)}⌸ sndPart

  ⍝ sort matrix above by sorting the values of the first column
  sortedM ← (⊂⍋m[; 1])⌷m

  ⍝ 1 1 1 means all colors present, 1 1 0 means blue and green present, red missing. and so on.
  colorsPresent ← ('blue' 'green' 'red') ∊ (⊃¨sortedM[; 1]) 

  ⍝ convert sortedMatrix to a matrix of only numbers. no color information.
  ⍝ also, transpose so that now each column corresponds to one color. before, each row corresponded to a color
  nums ← ⍉↑⍎¨¨sortedM[; 2]

  ⍝ in our final matrix, the first column should correspond to blue, the second one, green, and the last one red
  ⍝ in the case that there is a color missing, make sure that its column is just all 0s
  addedZeroes ← (calcRotation colorsPresent) ⌽ (⊃(⍴ nums)) 3 ↑ nums

  ⍝ convert matrix above to be a vector, each element will be the max of its column
  ⍝ create new vector by subtracting 14 from first col (blue), 13 from second column (green), and 12 from last column (red)
  ⍝ get minimum of new vector. set variable to 1 if the minimum is greater than or equal to 0. or 0 if minimum is smaller than 0
  isPossible ← 0≤⌊/14 13 12 - ⌈⌿addedZeroes

  ⍝ if variable was 1 return gameID. if variable was 0 return 0
  isPossible:gameID
  0
}

1 -->  000000000 , nums[; 1] , nums[; 2]
2 -->  nums[; 1] , 000000000 , nums[; 2]
3 -->  nums[; 1] , nums[; 2] , 000000000

0 -->  nums[; 1] , nums[; 2] , 000000000
1 -->  nums[; 1] , 000000000 , nums[; 2]
2 -->  000000000 , nums[; 1] , nums[; 2]
3 -->  nums[; 1] , nums[; 2] , 000000000
4 -->  nums[; 1] , 000000000 , nums[; 2]
5 -->  000000000 , nums[; 1] , nums[; 2]


input | desired output
0 1 1 |  2 or 5
1 0 1 |  1 or 4
1 1 0 |  0 or 3
-------------
0 0 1 | 3
0 1 0 | 2
1 0 0 | 1
attempt:
1-⍨⍸⌽~input

input | desired output
0 0 1 |  1
0 1 0 |  2
1 0 0 |  3
-------------
1 0 0 |  1 or 4
0 1 0 |  2 or 5
0 0 1 |  3 or 6
attempt:
⍸⌽input
